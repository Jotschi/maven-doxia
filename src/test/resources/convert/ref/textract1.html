<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title></title>
</head>
<body>
<h1>1 Constants and types related to class
<a href="#xstdataaccess">xstDataAccess</a> </h1>
<p>Macros:</p><pre>#define xskMaxBookmarkTypes             8
#define xskAttributeNameMaxLength       39
#define xskMaxUserTypes                 100
#define xskUserTypeNameMaxLength        39</pre><pre>typedef struct {
    char                  fName[xskUserTypeNameMaxLength+1];
    xstUserTypeCloneProc  fCloneProc;
    xstUserTypeDeleteProc fDeleteProc;
    xstUserTypeReadProc   fReadProc;
    xstUserTypeWriteProc  fWriteProc;
    xstUserTypePrintProc  fPrintProc;
    void*                 fProcData;
} xstUserType;</pre><p><a id="xstusertype" name="xstusertype">xstUserType</a>
</p><h1>2 Class
<a id="xstdataaccess" name="xstdataaccess">xstDataAccess</a></h1>
<p>Abstract class which models the access to a serie of numerical values
(samples) and to their associated attributes and marks.</p><p>Attributes are
used to specify the semantics of samples.</p><p>Marks are used to specify a
range of sample positions and/or ``interesting'' sample positions. There are 3
kinds of marks:</p><dl compact>
<dt><b>Point</b></dt>
<dd>the insertion point.</dd>
<dt><b>Mark</b></dt>
<dd>the selection mark. <p>A data set (even empty) always has a point and a
mark.</p><p>The selection is the subset of samples located between point and
mark. More precisely: if, for instance, point is located before mark, the
selection is the subset of samples located between point and mark, <i>point
included and mark excluded</i>.</p></dd>
<dt><b>Bookmarks</b></dt>
<dd>are used to specify ``interesting'' sample positions. <p>There are
xskMaxBookmarkTypes types of bookmarks. A newly created data set has no
bookmarks at all. One may add as many bookmarks (of any of the
xskMaxBookmarkTypes) types as he/she wants.</p></dd>
</dl><h2>2.1 Access to samples</h2>
<pre>virtual xstDataType DataType();</pre><p><a id="xstdataaccessdatatype" name="xstdataaccessdatatype">xstDataAccess::DataType</a>
returns the numerical type of the
samples.</p><pre>size_t SizeOfDataType();</pre><p><a id="xstdataaccesssizeofdatatype" name="xstdataaccesssizeofdatatype">xstDataAccess::SizeOfDataType</a>
returns the size in bytes (like sizeof) of the samples.</p><h2>2.2 Access to
marks</h2>
<pre>virtual int Point();</pre><p><a id="xstdataaccesspoint" name="xstdataaccesspoint">xstDataAccess::Point</a>
returns the insertion point (a sample position).</p><p>Note that a point equal
to this-&gt;Size() is a valid position which means after last
sample.</p><pre>virtual int Mark();</pre><p><a id="xstdataaccessmark" name="xstdataaccessmark">xstDataAccess::Mark</a>
returns the selection mark (a sample position).</p><p>Note that a mark equal
to this-&gt;Size() is a valid position which means after last
sample.</p><h2>2.3 Convenience functions for accessing samples</h2>
<pre>utStatus GetSample(int index, xstAnyValue&amp; value);
utStatus GetSample(int index, float&amp; value);</pre><p><a id="xstdataaccessgetsample" name="xstdataaccessgetsample">xstDataAccess::GetSample</a>
returns in <i>value</i> the value of sample
#<i>index</i>.</p><pre>utStatus GetSample(int index, double&amp; value);</pre><p>Another
one </p><pre>utStatus GetSamples(int index, float* values, int&amp; count);
utStatus GetSamples(int index, double* values, int&amp; count);</pre><p><a id="xstdataaccessgetsamples" name="xstdataaccessgetsamples">xstDataAccess::GetSamples</a>
works like <a href="#xstdataaccessget">xstDataAccess::Get</a> but
automatically converts samples read from the data set to float or double
values.</p><h2>2.4 Convenience functions for accessing attributes</h2>
<pre>utBool GetStringAttribute(const char*  name, const char*&amp; string);</pre><p><a id="xstdataaccessgetstringattribute" name="xstdataaccessgetstringattribute">xstDataAccess::GetStringAttribute</a>
returns in <i>string</i> the value of attribute called <i>name</i>. If such
attribute is found and actually is a string, this function returns true.
Otherwise, it returns false and <i>string</i> is set to
&quot;&quot;.</p><pre>utBool GetNumericAttribute(const char*  name, xstAnyValue&amp; number);</pre><p><a id="xstdataaccessgetnumericattribute" name="xstdataaccessgetnumericattribute">xstDataAccess::GetNumericAttribute</a>
returns in <i>number</i> the value of attribute called <i>name</i>. If such
attribute is found and actually is a number, this function returns true.
Otherwise, it returns false and <i>number</i> is set to
(utInt32)0.</p><pre>utBool GetNumericAttribute(const char* name, double&amp; number);</pre><p>Another
one.</p><p><a id="xstdataaccessgetname" name="xstdataaccessgetname">xstDataAccess::GetName</a>
works like
<a href="#xstdataaccessgetstringattribute">xstDataAccess::GetStringAttribute</a>
and returns in <i>name</i> the value of attribute xskName if any or
&quot;&quot;.</p><p>Single line.</p></body>
</html>
